# https://github.com/galmyk/nidgen

I use one of the Iranian mobile operators for my internet connection. Unfortunately, due to military unrest in the region, internal political and social conflicts, frequent power outages (which certainly affect BTSes) and various other reasons, I often encounter frequent internet outages or instability (several times a day and for hours a day in total).

Nowadays, a fast and high quality network connection is our inalienable right. All people need it for everyday life, let alone people like me who need it for work. If you think the problems mentioned above are unbearable and can't get any worse, you are wrong:

* Many services such as Docker registry, package manager repositories, mobile app stores, etc. are inaccessible to us due to international economic sanctions of Iran.
* Many widely used and popular services such as YouTube, Play Store, almost all social networks, video audio, movie streaming services, etc. are inaccessible to us duo to national filtering.

One day, while I was writing code at work and needed to install a Golang package to continue the project, I encountered an internet outage. Due to the urgent need for internet and a little fun, I installed the `wifite` package on my Arch Linux to access their wired ADSL connections. Of the several wireless networks available, approximately 25% did have WPS enabled, and within a few seconds, I extracted their passwords. What was interesting to me was that the passwords for two networks were national codes.

With this background and assuming that networks with WPS disabled may also have networks with national code passwords, All I had to do was create a text file, containing one national code per line, and use it as a dictionary to discover the password of WPA/WPA2 networks in wifite.

With a two-line Python script, the desired file can be created, which creates a set of ten-digit numbers. National codes in Iran are 10 digits long, and the rightmost digit, like many other coding systems, is used to verify the correctness of the code. Therefore, 90% of the national codes generated by the script are not correct inherently. With a little modification, or even using ready-made codes, you can filter incorrect codes, saving 90% of your and your system's time and energy to find wireless network passwords.

The good news is that you don't have to write such a program yourself. I've done it for you. The code is written in C and much faster than Python scripts.

To compile the program, just run the `make` command in the cloned folder. If you don't have `make`, you can install it, or compile the program without using `make`:

```
cc main.c -o nidgen
```

In the region where I live, most national codes start with the digits 203 or 497. To create a dict file containing all possible valid national codes that start with the given digits, simply run the following command:

```
./nidgen 203 497 > dict
```

You can pass any number of national code prefixes to the program. Just note that if you don't specify any prefixes, the program will start generating all valid national codes, which is one billion, and knowing that each national code requires 11 bytes of space (10 bytes + 1 byte for the newline character), it will require 1100000000 storage space (11 GB or 10.24 GiB).

You can now use the created file to discover the passwords of wireless networks around you.

Run `nidgen -h` to see a one-liner help output.

